---
layout: post
title: 优化算法之————动态规划（Dynamic Programming）
date: 2023-12-17
Author: nanxa 
tags: [algorithm, mcm_icm]
comments: true
toc: true
---

## 1. 概要
### 1.1 动态规划算法概念
动态规划（dynamic programming）是运筹学的一个分支，是求解决策过程（decision process）最优化的数学方法
* 阶段：对整个过程的自然划分，阶段变量一般用k = 1, 2, ... , n表示；
* 状态：每个阶段开始时过程所处的自然状况，用$x_k$表示第k阶段的状态变量，用$X_k$表示第k阶段允许的状态集合
* 决策：一个阶段的状态确定后，做出各种选择从而演变到下一阶段的某个状态，用$u_k(x_k)$表示第k阶段出于状态$x_k$的决策变量，用$U_k(x_k)$表示$x_k$的允许决策集合
* 策略：决策组成的序列由第k到第j阶段的子过程策略记为$p_{xj}(x_k)$ 
* 状态转移方程：表示状态和决策确定下一状态的演变规律，记
$$ x_{k+1} = T_k(x_k,u_k),k = 1,2,...,n$$
* 指标函数：衡量过程优劣的数量指标，记
$$ V_{k,n}(x_k,u_k,x_{k+1},...,x_{n+1})$$
* 最优值函数：使指标函数达到最优，记
$$ f_k(x_k) = optV_{k,n}(x_k,p_{kn})$$ 其中$opt$可取$max$或$min$

### 1.2 基本原理
**将给定的问题分解为多个更易求解的子问题，再对子问题分别求解，最后合并子问题的解以得到原问题的解**。通常情况下对许多子问题的求解过程非常相似，同类型的子问题只需求解一次（先将该解进行记忆化存储，之后求解子问题只需要查表即可），从而减少计算量。
>20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。
>1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。
### 1.3 算法模式
#### 自底向上：
一个大的问题往往都由很多小规模的子问题构成。而**由最小规模的子问题$ f(1), f(2)$开始层层向上推到原问题的过程就是自底向上的过程**。
* 在程序中，自底向上的算法通常由**循环**实现；而自顶向下的算法通常由**递归**实现

## 2. 应用场景和典型例题
### 2.1 应用场景
在数模比赛中，该类模型出现较少；该模型主要用于求解一些较为传统的最优化问题，如求解斐波那契数列、硬币兑换的方案数、背包问题等等

### 2.2 典型例题
* 最短路径问题：求解从起点到终点的最短路径
* 背包问题：求解在限定的体积和重量下，物品价值最大的组合
* 生产计划问题：求解在考虑一定的需求量、成本、储存费等因素的情况下能够使收益最大化的生产量和存储量

#### 2.2.1 最短路径
![Snipaste_2023-12-17_17-31-33.png](https://s2.loli.net/2023/12/17/ZVcylRtNEFUhSBi.png)
![Snipaste_2023-12-17_17-32-38.png](https://s2.loli.net/2023/12/17/JVZtKd7iz4OHqWu.png)
![Snipaste_2023-12-17_17-32-54.png](https://s2.loli.net/2023/12/17/4Q6auVf5lFANyRr.png)
![Snipaste_2023-12-17_17-33-06.png](https://s2.loli.net/2023/12/17/bIzSGxHM6hAjXqs.png)
#### 2.2.2 背包问题
![Snipaste_2023-12-17_18-23-49.png](https://s2.loli.net/2023/12/17/5tlkE7QPnO4ucyh.png)
```
#n：物品件数；c:最大承重为c的背包；w:各个物品的重量；v:各个物品的价值
#第一步建立最大价值矩阵(横坐标表示[0,c]整数背包承重):(n+1)*(c+1)
#技巧:python 生成二维数组(数组)通常先生成列再生成行
def bag(n,c,w,p)：
    res=[[-1 for j in range(c+1)]for i in range(n+1)]
    for j in range(c+1):
        #第0行全部赋值为0，物品编号从1开始.为了下面赋值方便
        res[0][j]=0
    for i in range(1:n+1):
        for j in range(1:c+1):
            res[i][j]=res[i-1][j]
            #生成了n*c有效矩阵，以下公式w[i-1],p[i-1]代表从第一个元素w[0],p[0]开始取。
            if(j>=w[i-1]) and res[i-1][j-w[i-1]]+p[i-1]>res[i][j]：
                res[i][j]=res[i-1][j-w[i-1]]+p[i-1]
    return res
#以下代码功能：标记出有放入背包的物品
#反过来标记，在相同价值情况下，后一件物品比前一件物品的最大价值大，则表示物品i#有被加入到背包，x数组设置为True。设初始为j=c。
def show(n,c,w,res):  
    print('最大价值为:',res[n][c])  
    x=[False for i in range(n)]  
    j=c  
    for i in range(1,n+1):  
        if res[i][j]>res[i-1][j]:  
            x[i-1]=True  
            j-=w[i-1]  
    print '选择的物品为:'  
    for i in range(n):  
        if x[i]:  
            print '第',i,'个,' 
    print'' 
if __name__=='__main__':  
    n=5  
    c=10  
    w=[2,2,6,5,4]  
    p=[6,3,5,4,6]  
    res=bag(n,c,w,p)  
    show(n,c,w,res)
```

#### 2.2.3 生产计划问题
![Snipaste_2023-12-17_18-27-39.png](https://s2.loli.net/2023/12/17/VPhpGiTrZSCY7jW.png)
![Snipaste_2023-12-17_18-27-49.png](https://s2.loli.net/2023/12/17/yGmLn3SxIDhjToP.png)

## 3. 步骤归纳
1. ***划分***：按照问题的特征，把问题分为**若干阶段**。注意：**划分后的阶段一定是有序的或者可排序的**
2. ***确定状态和状态变量***：将问题发展到各个阶段时所处的各种不同的客观情况表现出来。
3. ***确定决策并写出状态转移方程***：状态转移就是根据上一阶段的决策和状态来导出本阶段的状态。根据相邻两个阶段状态之间的联系来确定决策方法和**状态转移方程**
4. ***边界条件***：状态转移方程是一个递推式，因此需要找到递推终止的条件


参考文献
>1. 【数学建模笔记04】数学建模的动态规划 https://blog.csdn.net/weixin_45901207/article/details/119064039
>2. 动态规划算法详解 https://www.zhihu.com/tardis/zm/art/146611382?source_id=1003
